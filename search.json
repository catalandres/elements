[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Salesforce Elements",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "style/naming.html",
    "href": "style/naming.html",
    "title": "2  Naming",
    "section": "",
    "text": "2.1 General rules",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Naming</span>"
    ]
  },
  {
    "objectID": "style/naming.html#general-rules",
    "href": "style/naming.html#general-rules",
    "title": "2  Naming",
    "section": "",
    "text": "Any exception to this naming convention must be uncontroversial, generally accepted by the whole team, and well documented.\n\n\n2.1.1 Labels\n\nUser-exposed labels must be informative, expositive, and neutral.\nDo not include question marks in the label.\nNo corporate jargon, no acronyms, no abbreviations. When designing a user-exposed label, name it so that it would make sense to a new employee in their first day of work. Abbreviations and acronyms are OK only if they appear in a general purpose dictionary.\nTo reduce confusion, two configuration components of the same type that are exposed to the user will not share the same label. Exceptions to this rule are admissible as long as the components that would bear the same name are not visible to the user at the same time, they do not belong to the same metadata category, or they can be argued to be different enough.\n\n\n\n2.1.2 Developer names\n\nDeveloper names should closely follow the contents of the label whenever possible.\nUse PascalCase (uppercase camelCase) in all developer names. This improves both ergonomics (reduced chances of repeated stress injury) and consistency (Salesforce’s default naming for standard metadata components is PascalCase).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Naming</span>"
    ]
  },
  {
    "objectID": "style/naming.html#fields",
    "href": "style/naming.html#fields",
    "title": "2  Naming",
    "section": "2.2 Fields",
    "text": "2.2 Fields\n\n2.2.1 Address, email, phone and URL fields\n\nUnless there is another way to denote the data type, all fields will include whether the underlying data is an address, an email, a phone number or a URL (or website).\n\n\n\n2.2.2 Checkbox fields\n\nThe label should not start with a verb in personal form, but, typically, with a noun or an adjective.\nThe no-question-marks-in-labels rule applies here strictly.\nThe developer name should take the form of a question that can be answered with a yes/no answer, typically starting with Is, Has, Does, Do.\n\n\n\n2.2.3 Date, time and date/time fields\n\nIn Date fields, the word Date or Day will appear in the label and developer name, unless there is another way to denote the data type.\nIn Time fields, the word Time or Hour will appear in the label and developer name, unless there is another way to denote the data type.\nThe same will be true for Date/Time fields, with Moment or Timestamp as good examples of ways to incorporate the data type into the name of the field.\n\n\n\n2.2.4 Number, currency, and percent fields\n\nWe encourage dropping NumberOf in Number fields if the meaning of the field is clear without those words.\nDo not use “#” as a stand-in for the word “Number” in the field’s label.\nIn Percent fields there should be a word making evident that the value of the field is a percentage, ratio, proportion or margin. If applicable, it should make explicit with respect to what.\nIn Currency fields, consider adding Amount or a similar term if the meaning of the field is unclear.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Naming</span>"
    ]
  },
  {
    "objectID": "style/naming.html#auto-number",
    "href": "style/naming.html#auto-number",
    "title": "2  Naming",
    "section": "2.3 Auto Number",
    "text": "2.3 Auto Number\n\nThere is an option to set the Name field as an Auto Number field. When Name is Auto Number, consider renaming its label to “(name of the object) Code”, “(name of the object) Number”, or similar.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Naming</span>"
    ]
  },
  {
    "objectID": "style/naming.html#formula",
    "href": "style/naming.html#formula",
    "title": "2  Naming",
    "section": "2.4 Formula",
    "text": "2.4 Formula\n\nSome style guides enforce using _f as a suffix in the developer name of any formula, to differentiate between stored-value and calculated fields. This can be advantageous, because the conversion between a non-formula field into a formula field, or vice versa, requires the manual intervention of a release manager. Adding the suffix is neither encouraged or discouraged, as this convention is relatively onerous.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Naming</span>"
    ]
  },
  {
    "objectID": "style/apex.html",
    "href": "style/apex.html",
    "title": "3  Apex",
    "section": "",
    "text": "3.1 General principles\nThe goal is to have code that can be maintained well past the moment it goes live. Code that does not abide by these principles will have no future.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Apex</span>"
    ]
  },
  {
    "objectID": "style/apex.html#general-principles",
    "href": "style/apex.html#general-principles",
    "title": "3  Apex",
    "section": "",
    "text": "3.1.1 Standardization\n\nSticking, strictly or loosely, to a standard style reduces the ambiguity of the systema nd leads to more maintainable solutions.\nThe usage of tools like Prettier is encouraged, not required. This type of tools impose a format which, even if it does not allow much customization, is a positive step towards standardization.\n\n\n\n3.1.2 Clarity\n\nWhen variables, objects, classes are named properly, it is easier to understand the purpose of our code.\n\n\n\n3.1.3 Expressivity and readability\n\nCoding is, first and foremost, a communicative act containing a narrative exercise.\nPoorly formulated code should be addressed with the same degree of tolerance as poor grammar or lousy spelling in professional communication.\nCode is not only a message to be read by a machine, but also must be easy to understand by other team members, present and future, as well as the original developer’s future self, to ensure its future maintainability.\nThe developer’s intentions must be evident. Comments should not be necessary, but when they are they should provide sufficient context.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Apex</span>"
    ]
  },
  {
    "objectID": "style/apex.html#triggers",
    "href": "style/apex.html#triggers",
    "title": "3  Apex",
    "section": "3.2 Triggers",
    "text": "3.2 Triggers\n\nThere will only be one trigger per Salesforce object. The only exception to this rule will be those triggers installed as part of third-party packages, managed or unmanaged.\nThe filename of the trigger will be the developer name of the corresponding Salesforce object, in plural, because “Case” is a reserved word, and it would not be a legal name for a trigger or a class. As we should be using modern development tools (VisualStudio Code and the Salesforce CLI), metadata formatted according to the SFDX project format will add the metadata type to the extension of the XML file. That way we will get Accounts.trigger instead of AccountTrigger.trigger, which is redundant.\n\n\n\n\n\n\n\n\n\n\nObject\nInstead of this\nUse this\nTrigger filename\n\n\n\n\nAccount\nAccountTrigger\nAccounts\nAccounts.trigger\n\n\nCase\nCaseTrigger\nCases\nCases.trigger\n\n\nSubmission__c\nSubmissionTrigger\nSubmissions\nSubmissions.trigger\n\n\n\n\nEvery trigger should contain absolute zero business logic and have one and only one line. In that line, the trigger calls an Apex class that, based on the trigger context and data, performs a triage and determines the work to be done in the data. Some refer to this “triage class” as a “trigger handler class”.\n\nWhy do we want to remove all business logic from triggers? Because the only way to test a trigger is to perform a database operation, and those are very expensive in terms of computing time. Well formulated unit tests should avoid database operations, and that can only happen if we move that logic to the triage class.\nCan there be an exception to this rule? Yes. A single trigger can call two different triage classes, corresponding to completely different applications sitting in the same Salesforce org. This would mean that the trigger would include two lines of code, but still the logic would belong in the triage class. In this case, however, we would further decouple those applications using Custom Metadata Types to determine which triage classes should be called for each trigger.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Apex</span>"
    ]
  },
  {
    "objectID": "style/apex.html#classes",
    "href": "style/apex.html#classes",
    "title": "3  Apex",
    "section": "3.3 Classes",
    "text": "3.3 Classes\n\n3.3.1 Class types and separation of concerns\n\n3.3.1.1 Triage class\n\nA triage class takes the trigger context and data and performs the necessary operations to select which instances/records need to be treated and pass the values to a service class, or to an asynchronous class that will call a service class.\nThere should be only one triage class per object. In multi-application Salesforce orgs, it should be one triage class per object and application.\nIn general, triage classes do not perform any data modification operations directly (be it DML operations in after-save, or source data modifications in before-save trigger contexts). There can be exceptions if the operation to perform (e.g. some basic transformation, especially in before-save contexts) is minimal and there does not exist yet a service to hold the method.\nThe triage class is the one and only place where we make decisions on what to do based on the trigger context.\nUse Triage or Handler as the suffix of the class name to denote the class type.\n\n\n\n3.3.1.2 Service class\n\nA service class is a collection of typically static methods that performs operations over collections of records.\nThe service class is completely abstracted from the trigger context. It contains business and database logic. And it must be designed to be called from any context other than a trigger: Flow actions, asynchronous jobs, API endpoints, etc.\nUse Service as the suffix of the class name to denote the class type. The scope of the class will be denoted by its prefix. It can be as broad (e.g. CaseService) or narrow (e.g. OpportunityStageTransitionService) as we need it to be.\n\n\n\n3.3.1.3 Accessor class\n\nAn accessor class (also referred to as “selector class”) takes the responsibility to query the database. Ideally, all database queries should be done through an accessor class and not through inline SOQL/SOSL.\nAn advantage of using accessor classes is that they can be used to inject database results to be used in tests without having to perform time-expensive database operations, by strategically using @testAccessible decorators on private class properties.\nUse Accessor as the suffix for accessor classes.\n\n\n\n3.3.1.4 Asynchronous job class\n\nThe asynchronous job class is called from another context, trigger or otherwise, using the standard means (e.g. enqueueJob() for Queueable classes).\nThe class only contains the logic to manage the job (similar to the triage class) and generally delegates the business logic to a service.\nThese classes must implement either the Queueable (preferrable) or Batchable (fallback) interface.\nUse Job as the suffix for asynchronous job classes.\n\n\n\n3.3.1.5 Utility classes related to an SObject type\n\nThis class type is used to perform small operations in SObjects and their collections.\nUse the same naming convention as in triggers: name of the SObject in plural. Drop the suffix Util.\n\n\n\n3.3.1.6 Test classes\n\n(More details under Testing standards document.)\nEnsure that Test appears in the name of the class and it is a suffix and not a prefix.\nConsider differentiating between functional and unit tests by using different suffixes (e.g. UnitTest, FunctionalTest).\nIf the test class is a unit test for an existing class, ensure that the left side of the name matches the name of the class under test, so that they can sit side-by-side in any file list.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Apex</span>"
    ]
  },
  {
    "objectID": "style/users.html",
    "href": "style/users.html",
    "title": "4  Usernames",
    "section": "",
    "text": "4.1 Motivation\nUsernames must be globally unique across all Salesforce orgs and customers. While emails are unique within the organization, when an organization has (or will have, or will continue to have) multiple Salesforce org systems1, and sandbox names are not unique across org systems, so we need to use the MyDomain name to namespace them and make them truly unique.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Usernames</span>"
    ]
  },
  {
    "objectID": "style/users.html#footnotes",
    "href": "style/users.html#footnotes",
    "title": "4  Usernames",
    "section": "",
    "text": "An “org system” is a production environment and all its sandboxes.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Usernames</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "5  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]